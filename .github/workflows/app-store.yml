# ============================================================================
# Hablar√° - App Store Connect Upload Workflow
# ============================================================================
# Builds a signed Universal Binary and uploads to App Store Connect.
#
# Prerequisites (GitHub Secrets) - run scripts-dev/export-github-secrets.sh:
#   - APPLE_CERTIFICATES_BASE64: Base64-encoded .p12 (contains both certs)
#   - APPLE_CERTIFICATES_PASSWORD: Password for .p12
#   - PROVISIONING_PROFILE_BASE64: Base64-encoded .provisionprofile
#   - ASC_API_KEY_ID: App Store Connect API Key ID
#   - ASC_API_ISSUER_ID: App Store Connect Issuer ID
#   - ASC_API_PRIVATE_KEY_BASE64: Base64-encoded .p8 private key
#
# Usage:
#   1. Go to Actions tab in GitHub
#   2. Select "App Store Release"
#   3. Click "Run workflow"
#   4. Enter version (must match tauri.conf.json)
# ============================================================================

name: App Store Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.3)'
        required: true
        type: string

concurrency:
  group: app-store-release
  cancel-in-progress: false

env:
  APP_NAME: "Hablar√°"
  APP_IDENTIFIER: "com.fidpa.hablara"
  # Apple ID from App Store Connect (Meine Apps ‚Üí Hablar√° ‚Üí Allgemeine Informationen)
  APPLE_ID: "6758584671"

jobs:
  build-and-upload:
    name: Build & Upload to App Store
    runs-on: macos-14

    steps:
      # ========================================
      # 1. Checkout & Validation
      # ========================================
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate version
        run: |
          TAURI_VERSION=$(jq -r '.version' src-tauri/tauri.conf.json)
          if [ "$TAURI_VERSION" != "${{ inputs.version }}" ]; then
            echo "‚ùå Version mismatch! Input: ${{ inputs.version }}, tauri.conf.json: $TAURI_VERSION"
            exit 1
          fi
          echo "‚úÖ Version validated: ${{ inputs.version }}"

      # ========================================
      # 2. Setup Build Environment
      # ========================================
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-darwin,x86_64-apple-darwin

      - name: Setup Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # ========================================
      # 3. Build whisper.cpp & Download Model
      # ========================================
      - name: Cache whisper model
        id: cache-whisper-model
        uses: actions/cache@v4
        with:
          path: src-tauri/models/ggml-german-turbo.bin
          key: whisper-german-turbo-1.62gb

      - name: Download whisper german-turbo model
        if: steps.cache-whisper-model.outputs.cache-hit != 'true'
        run: |
          mkdir -p src-tauri/models
          echo "‚¨áÔ∏è Downloading german-turbo model (1.62 GB)..."
          curl -L --progress-bar \
            "https://huggingface.co/cstr/whisper-large-v3-turbo-german-ggml/resolve/main/ggml-model.bin" \
            -o src-tauri/models/ggml-german-turbo.bin
          ls -lh src-tauri/models/ggml-german-turbo.bin
          echo "‚úÖ Model downloaded"

      - name: Build whisper.cpp for Universal Binary
        run: |
          set -e  # Exit on any error

          echo "üì¶ Cloning whisper.cpp..."
          git clone --depth 1 https://github.com/ggml-org/whisper.cpp.git /tmp/whisper-build
          cd /tmp/whisper-build

          # Build for aarch64 (Apple Silicon with Metal)
          echo "üî® Building for aarch64 (Metal)..."
          cmake -B build-arm64 \
            -S . \
            -DCMAKE_OSX_ARCHITECTURES=arm64 \
            -DGGML_METAL=ON \
            -DCMAKE_BUILD_TYPE=Release \
            -DWHISPER_BUILD_EXAMPLES=ON

          if [ $? -ne 0 ]; then
            echo "‚ùå CMake configuration failed for arm64"
            exit 1
          fi

          cmake --build build-arm64 --config Release -j$(sysctl -n hw.ncpu)

          if [ $? -ne 0 ]; then
            echo "‚ùå CMake build failed for arm64"
            exit 1
          fi

          # Build for x86_64 (Intel)
          # GGML_NATIVE=OFF is critical for cross-compiling on ARM64 runner
          # Without it, cmake uses -mcpu=native which results in "apple-m1" - invalid for x86_64
          echo "üî® Building for x86_64..."
          cmake -B build-x64 \
            -S . \
            -DCMAKE_OSX_ARCHITECTURES=x86_64 \
            -DCMAKE_BUILD_TYPE=Release \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DGGML_NATIVE=OFF \
            -DGGML_METAL=OFF

          if [ $? -ne 0 ]; then
            echo "‚ùå CMake configuration failed for x86_64"
            exit 1
          fi

          cmake --build build-x64 --config Release -j$(sysctl -n hw.ncpu)

          if [ $? -ne 0 ]; then
            echo "‚ùå CMake build failed for x86_64"
            exit 1
          fi

          # Find the built binaries (use only whisper-cli, not main which is just deprecation warning)
          echo "üîç Searching for whisper-cli binaries..."
          ARM_BIN="build-arm64/bin/whisper-cli"
          X64_BIN="build-x64/bin/whisper-cli"

          if [ ! -f "$ARM_BIN" ]; then
            echo "‚ùå arm64 binary not found at $ARM_BIN"
            echo "Available files in build-arm64/bin:"
            ls -la build-arm64/bin/ || true
            exit 1
          fi

          if [ ! -f "$X64_BIN" ]; then
            echo "‚ùå x86_64 binary not found at $X64_BIN"
            echo "Available files in build-x64/bin:"
            ls -la build-x64/bin/ || true
            exit 1
          fi

          # Verify architectures
          echo "üîç Verifying binary architectures..."
          lipo -info "$ARM_BIN"
          lipo -info "$X64_BIN"

          # Install to Tauri binaries directory
          mkdir -p $GITHUB_WORKSPACE/src-tauri/binaries
          cp "$ARM_BIN" $GITHUB_WORKSPACE/src-tauri/binaries/whisper-aarch64-apple-darwin
          cp "$X64_BIN" $GITHUB_WORKSPACE/src-tauri/binaries/whisper-x86_64-apple-darwin
          chmod +x $GITHUB_WORKSPACE/src-tauri/binaries/whisper-*

          echo "‚úÖ whisper.cpp built for Universal Binary"
          ls -lh $GITHUB_WORKSPACE/src-tauri/binaries/

          # Add x86_64 resource to tauri.conf.json for universal build
          # (not in repo because local dev only needs aarch64)
          jq '.bundle.resources += ["binaries/whisper-x86_64-apple-darwin"]' \
            $GITHUB_WORKSPACE/src-tauri/tauri.conf.json > /tmp/tauri.conf.json.tmp
          mv /tmp/tauri.conf.json.tmp $GITHUB_WORKSPACE/src-tauri/tauri.conf.json
          echo "‚úÖ Added x86_64 resource to tauri.conf.json"

      # ========================================
      # 4. Import Certificates
      # ========================================
      - name: Import Apple certificates
        env:
          APPLE_CERTIFICATES_BASE64: ${{ secrets.APPLE_CERTIFICATES_BASE64 }}
          APPLE_CERTIFICATES_PASSWORD: ${{ secrets.APPLE_CERTIFICATES_PASSWORD }}
          PROVISIONING_PROFILE_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificates (base64 -d is POSIX-compatible)
          echo "$APPLE_CERTIFICATES_BASE64" | base64 -d > $RUNNER_TEMP/certificates.p12
          security import $RUNNER_TEMP/certificates.p12 \
            -P "$APPLE_CERTIFICATES_PASSWORD" \
            -A -t cert -f pkcs12 \
            -k $KEYCHAIN_PATH

          security list-keychain -d user -s $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Provisioning profile
          echo "$PROVISIONING_PROFILE_BASE64" | base64 -d > $RUNNER_TEMP/embedded.provisionprofile

          echo "‚úÖ Certificates imported"
          security find-identity -v -p codesigning $KEYCHAIN_PATH

      - name: Extract certificate SHA-1 hashes
        id: certs
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Use SHA-1 hash instead of name to avoid "ambiguous" error when cert appears twice
          # Format: "  1) HASH "Name""  -> extract HASH
          DIST_HASH=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep "Apple Distribution" | head -1 | awk '{print $2}')
          INST_HASH=$(security find-identity -v $KEYCHAIN_PATH | grep "3rd Party Mac Developer Installer" | head -1 | awk '{print $2}')

          if [ -z "$DIST_HASH" ]; then
            echo "::error::Apple Distribution certificate not found in keychain"
            security find-identity -v -p codesigning $KEYCHAIN_PATH
            exit 1
          fi
          if [ -z "$INST_HASH" ]; then
            echo "::error::3rd Party Mac Developer Installer certificate not found in keychain"
            security find-identity -v $KEYCHAIN_PATH
            exit 1
          fi

          echo "‚úÖ Distribution cert SHA-1: $DIST_HASH"
          echo "‚úÖ Installer cert SHA-1: $INST_HASH"

          echo "distribution_cert=$DIST_HASH" >> $GITHUB_OUTPUT
          echo "installer_cert=$INST_HASH" >> $GITHUB_OUTPUT

      # ========================================
      # 5. Build Universal Binary
      # ========================================
      - name: Build Tauri app
        run: pnpm tauri build --target universal-apple-darwin --bundles app

      - name: Verify build
        run: |
          APP_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${{ env.APP_NAME }}.app"
          echo "‚úÖ App: $APP_PATH"
          du -sh "$APP_PATH"
          lipo -info "$APP_PATH/Contents/MacOS/hablara"

      # ========================================
      # 6. Sign App Bundle
      # ========================================
      - name: Sign app bundle
        run: |
          APP_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${{ env.APP_NAME }}.app"
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          CERT="${{ steps.certs.outputs.distribution_cert }}"
          ENTITLEMENTS="src-tauri/entitlements.plist"

          # Embed provisioning profile
          cp $RUNNER_TEMP/embedded.provisionprofile "$APP_PATH/Contents/embedded.provisionprofile"

          # Sign all nested binaries first (deep signing)
          find "$APP_PATH/Contents/MacOS" -type f -perm +111 | while read binary; do
            echo "Signing binary: $binary"
            codesign --force --options runtime \
              --sign "$CERT" \
              --keychain $KEYCHAIN_PATH \
              --entitlements "$ENTITLEMENTS" \
              "$binary"
          done

          # Sign frameworks if any
          if [ -d "$APP_PATH/Contents/Frameworks" ]; then
            find "$APP_PATH/Contents/Frameworks" -name "*.dylib" -o -name "*.framework" | while read item; do
              echo "Signing framework: $item"
              codesign --force --options runtime \
                --sign "$CERT" \
                --keychain $KEYCHAIN_PATH \
                "$item" 2>/dev/null || true
            done
          fi

          # Sign the entire bundle
          codesign --force --options runtime \
            --sign "$CERT" \
            --keychain $KEYCHAIN_PATH \
            --entitlements "$ENTITLEMENTS" \
            "$APP_PATH"

          # Verify
          codesign --verify --deep --strict "$APP_PATH"
          echo "‚úÖ App signed and verified"

      # ========================================
      # 7. Create & Sign PKG
      # ========================================
      - name: Create signed PKG
        run: |
          set -e
          APP_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${{ env.APP_NAME }}.app"
          PKG_PATH="${{ runner.temp }}/${{ env.APP_NAME }}-${{ inputs.version }}.pkg"
          COMPONENT_PKG="${{ runner.temp }}/component.pkg"
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          INST_CERT="${{ steps.certs.outputs.installer_cert }}"

          # Step 1: Create component package with pkgbuild (fixes BOM/Payload mismatch)
          echo "üì¶ Creating component package with pkgbuild..."
          pkgbuild \
            --component "$APP_PATH" \
            --install-location /Applications \
            --sign "$INST_CERT" \
            --keychain $KEYCHAIN_PATH \
            "$COMPONENT_PKG"

          echo "‚úÖ Component PKG created: $(ls -lh "$COMPONENT_PKG" | awk '{print $5}')"

          # Step 2: Create distribution.xml (no quotes on EOF to allow variable expansion)
          echo "üìù Creating distribution.xml..."
          cat > "${{ runner.temp }}/distribution.xml" << EOF
          <?xml version="1.0" encoding="utf-8"?>
          <installer-gui-script minSpecVersion="2">
              <title>Hablar√°</title>
              <options customize="never" require-scripts="false" hostArchitectures="arm64,x86_64"/>
              <domains enable_anywhere="false" enable_currentUserHome="false" enable_localSystem="true"/>
              <choices-outline>
                  <line choice="default"/>
              </choices-outline>
              <choice id="default" title="Hablar√°">
                  <pkg-ref id="com.fidpa.hablara"/>
              </choice>
              <pkg-ref id="com.fidpa.hablara" version="${{ inputs.version }}" installKBytes="0">component.pkg</pkg-ref>
          </installer-gui-script>
          EOF

          # Step 3: Create final product archive with productbuild
          echo "üì¶ Creating final PKG with productbuild..."
          productbuild \
            --distribution "${{ runner.temp }}/distribution.xml" \
            --package-path "${{ runner.temp }}" \
            --sign "$INST_CERT" \
            --keychain $KEYCHAIN_PATH \
            "$PKG_PATH"

          echo "‚úÖ Final PKG created"
          ls -lh "$PKG_PATH"
          pkgutil --check-signature "$PKG_PATH"

          # Verify PKG contents
          echo "üìã PKG contents:"
          pkgutil --payload-files "$PKG_PATH" | head -20 || true

      - name: Upload PKG artifact
        uses: actions/upload-artifact@v4
        with:
          name: hablara-${{ inputs.version }}-macos-universal.pkg
          path: ${{ runner.temp }}/${{ env.APP_NAME }}-${{ inputs.version }}.pkg
          retention-days: 30

      # ========================================
      # 8. Upload to App Store Connect
      # ========================================
      - name: Setup API Key
        env:
          ASC_API_PRIVATE_KEY_BASE64: ${{ secrets.ASC_API_PRIVATE_KEY_BASE64 }}
          ASC_API_KEY_ID: ${{ secrets.ASC_API_KEY_ID }}
        run: |
          mkdir -p ~/.private_keys
          echo "$ASC_API_PRIVATE_KEY_BASE64" | base64 -d > ~/.private_keys/AuthKey_${ASC_API_KEY_ID}.p8
          chmod 600 ~/.private_keys/AuthKey_${ASC_API_KEY_ID}.p8

      - name: Upload to App Store Connect
        timeout-minutes: 30
        env:
          ASC_API_KEY_ID: ${{ secrets.ASC_API_KEY_ID }}
          ASC_API_ISSUER_ID: ${{ secrets.ASC_API_ISSUER_ID }}
        run: |
          PKG_PATH="${{ runner.temp }}/${{ env.APP_NAME }}-${{ inputs.version }}.pkg"

          xcrun altool --upload-package "$PKG_PATH" \
            --type macos \
            --apple-id "${{ env.APPLE_ID }}" \
            --apiKey "$ASC_API_KEY_ID" \
            --apiIssuer "$ASC_API_ISSUER_ID" \
            --bundle-id "${{ env.APP_IDENTIFIER }}" \
            --bundle-short-version-string "${{ inputs.version }}" \
            --bundle-version "${{ github.run_number }}"

          echo "‚úÖ Uploaded to App Store Connect"

      # ========================================
      # 9. Cleanup
      # ========================================
      - name: Cleanup
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db 2>/dev/null || true
          rm -f $RUNNER_TEMP/certificates.p12 $RUNNER_TEMP/embedded.provisionprofile
          rm -rf ~/.private_keys

      - name: Summary
        run: |
          echo "## ‚úÖ App Store Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Architecture:** Universal (arm64 + x86_64)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Build uploaded to App Store Connect. Check TestFlight in 5-15 minutes." >> $GITHUB_STEP_SUMMARY
