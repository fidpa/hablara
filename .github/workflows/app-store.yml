# ============================================================================
# HablarÃ¡ - App Store Connect Upload Workflow
# ============================================================================
# Builds a signed Universal Binary and uploads to App Store Connect.
#
# Prerequisites (GitHub Secrets):
#   - APPLE_CERTIFICATES_BASE64: Base64-encoded .p12 (contains both certs)
#   - APPLE_CERTIFICATES_PASSWORD: Password for .p12
#   - PROVISIONING_PROFILE_BASE64: Base64-encoded .provisionprofile
#   - ASC_API_KEY_ID: App Store Connect API Key ID
#   - ASC_API_ISSUER_ID: App Store Connect Issuer ID
#   - ASC_API_PRIVATE_KEY_BASE64: Base64-encoded .p8 private key
#
# Usage:
#   1. Go to Actions tab in GitHub
#   2. Select "App Store Release"
#   3. Click "Run workflow"
#   4. Enter version (must match tauri.conf.json)
# ============================================================================

name: App Store Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.3)'
        required: true
        type: string

concurrency:
  group: app-store-release
  cancel-in-progress: false

env:
  APP_NAME: "Hablara"
  APP_IDENTIFIER: "com.fidpa.hablara"
  # Apple ID from App Store Connect (Meine Apps â†’ HablarÃ¡ â†’ Allgemeine Informationen)
  APPLE_ID: "6758584671"

jobs:
  build-and-upload:
    name: Build & Upload to App Store
    runs-on: macos-14

    steps:
      # ========================================
      # 1. Checkout & Validation
      # ========================================
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate version
        run: |
          TAURI_VERSION=$(jq -r '.version' src-tauri/tauri.conf.json)
          if [ "$TAURI_VERSION" != "${{ inputs.version }}" ]; then
            echo "âŒ Version mismatch! Input: ${{ inputs.version }}, tauri.conf.json: $TAURI_VERSION"
            exit 1
          fi
          echo "âœ… Version validated: ${{ inputs.version }}"

      # ========================================
      # 2. Setup Build Environment
      # ========================================
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-darwin,x86_64-apple-darwin

      - name: Setup Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # ========================================
      # 3. Build whisper.cpp & Download Model
      # ========================================
      - name: Cache whisper model
        id: cache-whisper-model
        uses: actions/cache@v4
        with:
          path: src-tauri/models/ggml-german-turbo.bin
          key: whisper-german-turbo-1.62gb

      - name: Download whisper german-turbo model
        if: steps.cache-whisper-model.outputs.cache-hit != 'true'
        run: |
          mkdir -p src-tauri/models
          echo "â¬‡ï¸ Downloading german-turbo model (1.62 GB)..."
          curl -L --progress-bar \
            "https://huggingface.co/cstr/whisper-large-v3-turbo-german-ggml/resolve/main/ggml-model.bin" \
            -o src-tauri/models/ggml-german-turbo.bin
          ls -lh src-tauri/models/ggml-german-turbo.bin
          echo "âœ… Model downloaded"

      - name: Build whisper.cpp for Universal Binary
        run: |
          set -e  # Exit on any error

          echo "ðŸ“¦ Cloning whisper.cpp..."
          git clone --depth 1 https://github.com/ggml-org/whisper.cpp.git /tmp/whisper-build
          cd /tmp/whisper-build

          # Build for aarch64 (Apple Silicon with Metal)
          echo "ðŸ”¨ Building for aarch64 (Metal)..."
          cmake -B build-arm64 \
            -S . \
            -DCMAKE_OSX_ARCHITECTURES=arm64 \
            -DGGML_METAL=ON \
            -DCMAKE_BUILD_TYPE=Release \
            -DWHISPER_BUILD_EXAMPLES=ON

          if [ $? -ne 0 ]; then
            echo "âŒ CMake configuration failed for arm64"
            exit 1
          fi

          cmake --build build-arm64 --config Release -j$(sysctl -n hw.ncpu)

          if [ $? -ne 0 ]; then
            echo "âŒ CMake build failed for arm64"
            exit 1
          fi

          # Build for x86_64 (Intel)
          # GGML_NATIVE=OFF is critical for cross-compiling on ARM64 runner
          # Without it, cmake uses -mcpu=native which results in "apple-m1" - invalid for x86_64
          echo "ðŸ”¨ Building for x86_64..."
          cmake -B build-x64 \
            -S . \
            -DCMAKE_OSX_ARCHITECTURES=x86_64 \
            -DCMAKE_BUILD_TYPE=Release \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DGGML_NATIVE=OFF \
            -DGGML_METAL=OFF

          if [ $? -ne 0 ]; then
            echo "âŒ CMake configuration failed for x86_64"
            exit 1
          fi

          cmake --build build-x64 --config Release -j$(sysctl -n hw.ncpu)

          if [ $? -ne 0 ]; then
            echo "âŒ CMake build failed for x86_64"
            exit 1
          fi

          # Find the built binaries (use only whisper-cli, not main which is just deprecation warning)
          echo "ðŸ” Searching for whisper-cli binaries..."
          ARM_BIN="build-arm64/bin/whisper-cli"
          X64_BIN="build-x64/bin/whisper-cli"

          if [ ! -f "$ARM_BIN" ]; then
            echo "âŒ arm64 binary not found at $ARM_BIN"
            echo "Available files in build-arm64/bin:"
            ls -la build-arm64/bin/ || true
            exit 1
          fi

          if [ ! -f "$X64_BIN" ]; then
            echo "âŒ x86_64 binary not found at $X64_BIN"
            echo "Available files in build-x64/bin:"
            ls -la build-x64/bin/ || true
            exit 1
          fi

          # Verify architectures
          echo "ðŸ” Verifying binary architectures..."
          lipo -info "$ARM_BIN"
          lipo -info "$X64_BIN"

          # Install to Tauri binaries directory
          mkdir -p $GITHUB_WORKSPACE/src-tauri/binaries
          cp "$ARM_BIN" $GITHUB_WORKSPACE/src-tauri/binaries/whisper-aarch64-apple-darwin
          cp "$X64_BIN" $GITHUB_WORKSPACE/src-tauri/binaries/whisper-x86_64-apple-darwin
          chmod +x $GITHUB_WORKSPACE/src-tauri/binaries/whisper-*

          echo "âœ… whisper.cpp built for Universal Binary"
          ls -lh $GITHUB_WORKSPACE/src-tauri/binaries/

          # Add x86_64 resource to tauri.conf.json for universal build
          # (not in repo because local dev only needs aarch64)
          jq '.bundle.resources += ["binaries/whisper-x86_64-apple-darwin"]' \
            $GITHUB_WORKSPACE/src-tauri/tauri.conf.json > /tmp/tauri.conf.json.tmp
          mv /tmp/tauri.conf.json.tmp $GITHUB_WORKSPACE/src-tauri/tauri.conf.json
          echo "âœ… Added x86_64 resource to tauri.conf.json"

      # ========================================
      # 4. Import Certificates
      # ========================================
      - name: Import Apple certificates
        env:
          APPLE_CERTIFICATES_BASE64: ${{ secrets.APPLE_CERTIFICATES_BASE64 }}
          APPLE_CERTIFICATES_PASSWORD: ${{ secrets.APPLE_CERTIFICATES_PASSWORD }}
          PROVISIONING_PROFILE_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificates (base64 -d is POSIX-compatible)
          echo "$APPLE_CERTIFICATES_BASE64" | base64 -d > $RUNNER_TEMP/certificates.p12
          security import $RUNNER_TEMP/certificates.p12 \
            -P "$APPLE_CERTIFICATES_PASSWORD" \
            -A -t cert -f pkcs12 \
            -k $KEYCHAIN_PATH

          security list-keychain -d user -s $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Provisioning profile
          echo "$PROVISIONING_PROFILE_BASE64" | base64 -d > $RUNNER_TEMP/embedded.provisionprofile

          echo "âœ… Certificates imported"
          security find-identity -v -p codesigning $KEYCHAIN_PATH

      - name: Extract certificate SHA-1 hashes
        id: certs
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Use SHA-1 hash instead of name to avoid "ambiguous" error when cert appears twice
          # Format: "  1) HASH "Name""  -> extract HASH
          DIST_HASH=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep "Apple Distribution" | head -1 | awk '{print $2}')
          INST_HASH=$(security find-identity -v $KEYCHAIN_PATH | grep "3rd Party Mac Developer Installer" | head -1 | awk '{print $2}')

          if [ -z "$DIST_HASH" ]; then
            echo "::error::Apple Distribution certificate not found in keychain"
            security find-identity -v -p codesigning $KEYCHAIN_PATH
            exit 1
          fi
          if [ -z "$INST_HASH" ]; then
            echo "::error::3rd Party Mac Developer Installer certificate not found in keychain"
            security find-identity -v $KEYCHAIN_PATH
            exit 1
          fi

          echo "âœ… Distribution cert SHA-1: $DIST_HASH"
          echo "âœ… Installer cert SHA-1: $INST_HASH"

          echo "distribution_cert=$DIST_HASH" >> $GITHUB_OUTPUT
          echo "installer_cert=$INST_HASH" >> $GITHUB_OUTPUT

      # ========================================
      # 5. Build Universal Binary
      # ========================================
      - name: Build Tauri app
        run: pnpm tauri build --target universal-apple-darwin --bundles app

      - name: Verify build and patch Info.plist
        run: |
          APP_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${{ env.APP_NAME }}.app"
          echo "âœ… App: $APP_PATH"
          du -sh "$APP_PATH"
          lipo -info "$APP_PATH/Contents/MacOS/hablara"

          # Set CFBundleDisplayName for accented display name in Finder/Dock
          plutil -replace CFBundleDisplayName -string "HablarÃ¡" "$APP_PATH/Contents/Info.plist"
          echo "âœ… CFBundleDisplayName set to 'HablarÃ¡'"

          # Set CFBundleVersion to match --bundle-version in altool upload
          plutil -replace CFBundleVersion -string "${{ github.run_number }}" "$APP_PATH/Contents/Info.plist"
          echo "âœ… CFBundleVersion set to '${{ github.run_number }}'"

      # ========================================
      # 6. Sign App Bundle
      # ========================================
      - name: Sign app bundle
        run: |
          APP_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${{ env.APP_NAME }}.app"
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          CERT="${{ steps.certs.outputs.distribution_cert }}"
          ENTITLEMENTS="src-tauri/entitlements.plist"

          # Embed provisioning profile
          cp $RUNNER_TEMP/embedded.provisionprofile "$APP_PATH/Contents/embedded.provisionprofile"

          # Sign whisper binaries with CHILD entitlements (inherit sandbox, no provisioning profile needed)
          # Using child-entitlements.plist instead of main entitlements to avoid ITMS-90885
          CHILD_ENTITLEMENTS="src-tauri/child-entitlements.plist"
          echo "Signing whisper binaries with child entitlements..."
          for binary in "$APP_PATH/Contents/Resources/binaries/whisper-"*; do
            if [ -f "$binary" ]; then
              echo "Signing: $binary"
              codesign --force --options runtime \
                --sign "$CERT" \
                --keychain $KEYCHAIN_PATH \
                --entitlements "$CHILD_ENTITLEMENTS" \
                "$binary"
            fi
          done

          # Sign all nested binaries in MacOS (deep signing)
          find "$APP_PATH/Contents/MacOS" -type f -perm +111 | while read binary; do
            echo "Signing binary: $binary"
            codesign --force --options runtime \
              --sign "$CERT" \
              --keychain $KEYCHAIN_PATH \
              --entitlements "$ENTITLEMENTS" \
              "$binary"
          done

          # Sign frameworks if any
          if [ -d "$APP_PATH/Contents/Frameworks" ]; then
            find "$APP_PATH/Contents/Frameworks" -name "*.dylib" -o -name "*.framework" | while read item; do
              echo "Signing framework: $item"
              codesign --force --options runtime \
                --sign "$CERT" \
                --keychain $KEYCHAIN_PATH \
                "$item" 2>/dev/null || true
            done
          fi

          # Sign the entire bundle
          codesign --force --options runtime \
            --sign "$CERT" \
            --keychain $KEYCHAIN_PATH \
            --entitlements "$ENTITLEMENTS" \
            "$APP_PATH"

          # Verify
          codesign --verify --deep --strict "$APP_PATH"
          echo "âœ… App signed and verified"

      # ========================================
      # 7. Create & Sign PKG
      # ========================================
      - name: Create signed PKG
        run: |
          set -e
          APP_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${{ env.APP_NAME }}.app"
          PKG_PATH="${{ runner.temp }}/${{ env.APP_NAME }}-${{ inputs.version }}.pkg"
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          INST_CERT="${{ steps.certs.outputs.installer_cert }}"

          # Verify app exists and has content
          echo "ðŸ“‹ Verifying app bundle..."
          ls -la "$APP_PATH/"
          ls -la "$APP_PATH/Contents/"
          ls -la "$APP_PATH/Contents/MacOS/"
          file "$APP_PATH/Contents/MacOS/hablara"

          # Verify code signature before PKG creation
          echo "ðŸ” Verifying app signature..."
          codesign -dvvv "$APP_PATH"

          # Copy app to temp location using ditto (preserves Extended Attributes + symlinks)
          TEMP_APP="${{ runner.temp }}/${{ env.APP_NAME }}.app"
          echo "ðŸ“¦ Copying app with ditto (preserves xattrs)..."
          ditto "$APP_PATH" "$TEMP_APP"

          # Verify ditto copy
          echo "ðŸ“‹ Verifying ditto copy..."
          codesign -dvvv "$TEMP_APP"

          # Create signed PKG with productbuild --component (App Store required method)
          # Reference: https://v2.tauri.app/distribute/app-store/
          echo "ðŸ“¦ Creating PKG with productbuild --component..."
          xcrun productbuild \
            --sign "$INST_CERT" \
            --keychain "$KEYCHAIN_PATH" \
            --component "$TEMP_APP" /Applications \
            "$PKG_PATH"

          echo "âœ… PKG created"
          ls -lh "$PKG_PATH"

          # Verify signature
          echo "ðŸ” Verifying PKG signature..."
          pkgutil --check-signature "$PKG_PATH"

          # Verify PKG contents
          echo "ðŸ“‹ PKG payload files (first 30):"
          pkgutil --payload-files "$PKG_PATH" | head -30 || echo "Warning: Could not list payload files"

          # Expand and verify PKG structure
          echo "ðŸ“‹ Expanding PKG to verify structure..."
          EXPAND_DIR="${{ runner.temp }}/pkg-expanded"
          pkgutil --expand "$PKG_PATH" "$EXPAND_DIR" || echo "Warning: Could not expand PKG"
          ls -la "$EXPAND_DIR/" || true
          ls -la "$EXPAND_DIR/"*.pkg/ 2>/dev/null || true

      - name: Upload PKG artifact
        uses: actions/upload-artifact@v4
        with:
          name: hablara-${{ inputs.version }}-macos-universal.pkg
          path: ${{ runner.temp }}/${{ env.APP_NAME }}-${{ inputs.version }}.pkg
          retention-days: 30

      # ========================================
      # 8. Upload to App Store Connect
      # ========================================
      - name: Setup API Key
        env:
          ASC_API_PRIVATE_KEY_BASE64: ${{ secrets.ASC_API_PRIVATE_KEY_BASE64 }}
          ASC_API_KEY_ID: ${{ secrets.ASC_API_KEY_ID }}
        run: |
          mkdir -p ~/.private_keys
          echo "$ASC_API_PRIVATE_KEY_BASE64" | base64 -d > ~/.private_keys/AuthKey_${ASC_API_KEY_ID}.p8
          chmod 600 ~/.private_keys/AuthKey_${ASC_API_KEY_ID}.p8

      - name: Upload to App Store Connect
        timeout-minutes: 30
        env:
          ASC_API_KEY_ID: ${{ secrets.ASC_API_KEY_ID }}
          ASC_API_ISSUER_ID: ${{ secrets.ASC_API_ISSUER_ID }}
        run: |
          PKG_PATH="${{ runner.temp }}/${{ env.APP_NAME }}-${{ inputs.version }}.pkg"

          xcrun altool --upload-package "$PKG_PATH" \
            --type macos \
            --apple-id "${{ env.APPLE_ID }}" \
            --apiKey "$ASC_API_KEY_ID" \
            --apiIssuer "$ASC_API_ISSUER_ID" \
            --bundle-id "${{ env.APP_IDENTIFIER }}" \
            --bundle-short-version-string "${{ inputs.version }}" \
            --bundle-version "${{ github.run_number }}"

          echo "âœ… Uploaded to App Store Connect"

      # ========================================
      # 9. Cleanup
      # ========================================
      - name: Cleanup
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db 2>/dev/null || true
          rm -f $RUNNER_TEMP/certificates.p12 $RUNNER_TEMP/embedded.provisionprofile
          rm -rf ~/.private_keys

      - name: Summary
        run: |
          echo "## âœ… App Store Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Architecture:** Universal (arm64 + x86_64)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Build uploaded to App Store Connect. Check TestFlight in 5-15 minutes." >> $GITHUB_STEP_SUMMARY
