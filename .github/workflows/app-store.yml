# ============================================================================
# Hablar√° - App Store Connect Upload Workflow
# ============================================================================
# Builds a signed Universal Binary and uploads to App Store Connect.
#
# Prerequisites (GitHub Secrets):
#   - APPLE_CERTIFICATES_BASE64: Base64-encoded .p12 (contains both certs)
#   - APPLE_CERTIFICATES_PASSWORD: Password for .p12
#   - PROVISIONING_PROFILE_BASE64: Base64-encoded .provisionprofile
#   - ASC_API_KEY_ID: App Store Connect API Key ID
#   - ASC_API_ISSUER_ID: App Store Connect Issuer ID
#   - ASC_API_PRIVATE_KEY_BASE64: Base64-encoded .p8 private key
#
# Usage:
#   1. Go to Actions tab in GitHub
#   2. Select "App Store Release"
#   3. Click "Run workflow"
#   4. Enter version (must match tauri.conf.json)
# ============================================================================

name: App Store Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.0.3)'
        required: true
        type: string

concurrency:
  group: app-store-release
  cancel-in-progress: false

env:
  APP_NAME: "Hablara"
  APP_IDENTIFIER: "com.fidpa.hablara"
  # Apple ID from App Store Connect (Meine Apps ‚Üí Hablar√° ‚Üí Allgemeine Informationen)
  APPLE_ID: "6758584671"

jobs:
  build-and-upload:
    name: Build & Upload to App Store
    runs-on: macos-14

    steps:
      # ========================================
      # 1. Checkout & Validation
      # ========================================
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate version
        run: |
          TAURI_VERSION=$(jq -r '.version' src-tauri/tauri.conf.json)
          if [ "$TAURI_VERSION" != "${{ inputs.version }}" ]; then
            echo "‚ùå Version mismatch! Input: ${{ inputs.version }}, tauri.conf.json: $TAURI_VERSION"
            exit 1
          fi
          echo "‚úÖ Version validated: ${{ inputs.version }}"

      # ========================================
      # 2. Setup Build Environment
      # ========================================
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-darwin,x86_64-apple-darwin

      - name: Setup Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # ========================================
      # 3. Build whisper.cpp & Download Model
      # ========================================
      - name: Cache whisper model
        id: cache-whisper-model
        uses: actions/cache@v4
        with:
          path: src-tauri/models/ggml-german-turbo.bin
          key: whisper-german-turbo-1.62gb

      - name: Download whisper german-turbo model
        if: steps.cache-whisper-model.outputs.cache-hit != 'true'
        run: |
          mkdir -p src-tauri/models
          echo "‚¨áÔ∏è Downloading german-turbo model (1.62 GB)..."
          curl -L --progress-bar \
            "https://huggingface.co/cstr/whisper-large-v3-turbo-german-ggml/resolve/main/ggml-model.bin" \
            -o src-tauri/models/ggml-german-turbo.bin
          ls -lh src-tauri/models/ggml-german-turbo.bin
          echo "‚úÖ Model downloaded"

      - name: Build whisper.cpp for Universal Binary
        run: |
          set -e  # Exit on any error

          echo "üì¶ Cloning whisper.cpp (pinned to v1.7.2)..."
          git clone --depth 1 --branch v1.7.2 https://github.com/ggml-org/whisper.cpp.git /tmp/whisper-build
          cd /tmp/whisper-build

          # SECURITY: Verify commit SHA to prevent supply chain attacks
          EXPECTED_SHA="6266a9f9e56a5b925e9892acf650f3eb1245814d"  # v1.7.2
          ACTUAL_SHA=$(git rev-parse HEAD)
          if [ "$ACTUAL_SHA" != "$EXPECTED_SHA" ]; then
            echo "‚ùå whisper.cpp commit SHA mismatch!"
            echo "Expected: $EXPECTED_SHA"
            echo "Actual:   $ACTUAL_SHA"
            exit 1
          fi
          echo "‚úÖ Commit SHA verified: OK (v1.7.2)"

          # Build for aarch64 (Apple Silicon with Metal)
          # BUILD_SHARED_LIBS=OFF ensures static linking (no @rpath dylib dependencies)
          echo "üî® Building for aarch64 (Metal, static)..."
          cmake -B build-arm64 \
            -S . \
            -DCMAKE_OSX_ARCHITECTURES=arm64 \
            -DGGML_METAL=ON \
            -DCMAKE_BUILD_TYPE=Release \
            -DBUILD_SHARED_LIBS=OFF \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_EXAMPLES=ON

          cmake --build build-arm64 --config Release -j$(sysctl -n hw.ncpu)

          # Build for x86_64 (Intel)
          # GGML_NATIVE=OFF is critical for cross-compiling on ARM64 runner
          # Without it, cmake uses -mcpu=native which results in "apple-m1" - invalid for x86_64
          echo "üî® Building for x86_64 (static)..."
          cmake -B build-x64 \
            -S . \
            -DCMAKE_OSX_ARCHITECTURES=x86_64 \
            -DCMAKE_BUILD_TYPE=Release \
            -DBUILD_SHARED_LIBS=OFF \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_EXAMPLES=ON \
            -DGGML_NATIVE=OFF \
            -DGGML_METAL=OFF

          cmake --build build-x64 --config Release -j$(sysctl -n hw.ncpu)

          # Find binaries (whisper.cpp v1.7.x uses 'main' for CLI)
          echo "üîç Searching for whisper binary..."
          ARM_BIN=""
          X64_BIN=""
          for name in "build-arm64/bin/whisper-cli" "build-arm64/bin/main"; do
            if [ -f "$name" ]; then ARM_BIN="$name"; break; fi
          done
          for name in "build-x64/bin/whisper-cli" "build-x64/bin/main"; do
            if [ -f "$name" ]; then X64_BIN="$name"; break; fi
          done

          if [ -z "$ARM_BIN" ]; then
            echo "‚ùå arm64 binary not found"
            ls -la build-arm64/bin/ || true
            exit 1
          fi

          if [ -z "$X64_BIN" ]; then
            echo "‚ùå x86_64 binary not found"
            ls -la build-x64/bin/ || true
            exit 1
          fi

          # Verify architectures
          echo "üîç Verifying binary architectures..."
          lipo -info "$ARM_BIN"
          lipo -info "$X64_BIN"

          # Verify static linking (no @rpath dependencies)
          echo "üîç Verifying static linking..."
          if otool -L "$ARM_BIN" | grep -q '@rpath'; then
            echo "‚ùå ERROR: arm64 binary has @rpath dependencies!"
            otool -L "$ARM_BIN"
            exit 1
          fi
          if otool -L "$X64_BIN" | grep -q '@rpath'; then
            echo "‚ùå ERROR: x64 binary has @rpath dependencies!"
            otool -L "$X64_BIN"
            exit 1
          fi
          echo "‚úÖ Both binaries are statically linked"

          # Install to Tauri binaries directory
          mkdir -p $GITHUB_WORKSPACE/src-tauri/binaries
          cp "$ARM_BIN" $GITHUB_WORKSPACE/src-tauri/binaries/whisper-aarch64-apple-darwin
          cp "$X64_BIN" $GITHUB_WORKSPACE/src-tauri/binaries/whisper-x86_64-apple-darwin
          chmod +x $GITHUB_WORKSPACE/src-tauri/binaries/whisper-*

          echo "‚úÖ whisper.cpp built for Universal Binary"
          ls -lh $GITHUB_WORKSPACE/src-tauri/binaries/

          # Add x86_64 resource to tauri.conf.json for universal build
          # (not in repo because local dev only needs aarch64)
          jq '.bundle.resources += ["binaries/whisper-x86_64-apple-darwin"]' \
            $GITHUB_WORKSPACE/src-tauri/tauri.conf.json > /tmp/tauri.conf.json.tmp
          mv /tmp/tauri.conf.json.tmp $GITHUB_WORKSPACE/src-tauri/tauri.conf.json
          echo "‚úÖ Added x86_64 resource to tauri.conf.json"

      # ========================================
      # 3b. Build Frontend (explicit step for debugging)
      # ========================================
      - name: Build frontend (Next.js)
        run: |
          echo "üî® Building Next.js frontend..."
          pnpm run build

          echo ""
          echo "=== Verify out/ directory exists ==="
          if [ -d "out" ]; then
            echo "‚úÖ out/ directory exists"
            ls -la out/ | head -20
            echo ""
            echo "=== Check for index.html ==="
            if [ -f "out/index.html" ]; then
              echo "‚úÖ index.html exists ($(wc -c < out/index.html) bytes)"
            else
              echo "‚ùå ERROR: index.html NOT FOUND!"
              exit 1
            fi
            echo ""
            echo "=== Check for _next/ ==="
            if [ -d "out/_next" ]; then
              echo "‚úÖ _next/ directory exists"
              find out/_next -type f | wc -l | xargs echo "   Files in _next/:"
            else
              echo "‚ùå ERROR: _next/ directory NOT FOUND!"
              exit 1
            fi
          else
            echo "‚ùå ERROR: out/ directory NOT FOUND!"
            echo "Current directory contents:"
            ls -la
            exit 1
          fi

      # ========================================
      # 4. Import Certificates
      # ========================================
      - name: Import Apple certificates
        env:
          APPLE_CERTIFICATES_BASE64: ${{ secrets.APPLE_CERTIFICATES_BASE64 }}
          APPLE_CERTIFICATES_PASSWORD: ${{ secrets.APPLE_CERTIFICATES_PASSWORD }}
          PROVISIONING_PROFILE_BASE64: ${{ secrets.PROVISIONING_PROFILE_BASE64 }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificates (base64 -d is POSIX-compatible)
          echo "$APPLE_CERTIFICATES_BASE64" | base64 -d > $RUNNER_TEMP/certificates.p12
          security import $RUNNER_TEMP/certificates.p12 \
            -P "$APPLE_CERTIFICATES_PASSWORD" \
            -A -t cert -f pkcs12 \
            -k $KEYCHAIN_PATH

          security list-keychain -d user -s $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Provisioning profile
          echo "$PROVISIONING_PROFILE_BASE64" | base64 -d > $RUNNER_TEMP/embedded.provisionprofile

          echo "‚úÖ Certificates imported"
          security find-identity -v -p codesigning $KEYCHAIN_PATH

      - name: Extract certificate SHA-1 hashes
        id: certs
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Use SHA-1 hash instead of name to avoid "ambiguous" error when cert appears twice
          # Format: "  1) HASH "Name""  -> extract HASH
          DIST_HASH=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep "Apple Distribution" | head -1 | awk '{print $2}')
          INST_HASH=$(security find-identity -v $KEYCHAIN_PATH | grep "3rd Party Mac Developer Installer" | head -1 | awk '{print $2}')

          if [ -z "$DIST_HASH" ]; then
            echo "::error::Apple Distribution certificate not found in keychain"
            security find-identity -v -p codesigning $KEYCHAIN_PATH
            exit 1
          fi
          if [ -z "$INST_HASH" ]; then
            echo "::error::3rd Party Mac Developer Installer certificate not found in keychain"
            security find-identity -v $KEYCHAIN_PATH
            exit 1
          fi

          echo "‚úÖ Distribution cert SHA-1: $DIST_HASH"
          echo "‚úÖ Installer cert SHA-1: $INST_HASH"

          echo "distribution_cert=$DIST_HASH" >> $GITHUB_OUTPUT
          echo "installer_cert=$INST_HASH" >> $GITHUB_OUTPUT

      # ========================================
      # 5. Build Universal Binary
      # ========================================
      - name: Build Tauri app
        run: pnpm tauri build --target universal-apple-darwin --bundles app
        env:
          NEXT_PUBLIC_APP_STORE: "true"

      # Workaround: Tauri bundler bug doesn't copy frontend in Universal Binary builds
      # See: https://github.com/tauri-apps/tauri/issues - Universal Binary frontend bundling
      - name: Copy frontend to bundle (Universal Binary workaround)
        run: |
          APP_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${{ env.APP_NAME }}.app"
          UP_DIR="$APP_PATH/Contents/Resources/_up_"

          echo "üîß Manual frontend copy (Tauri Universal Binary bundler workaround)"
          echo "Source: out/"
          echo "Target: $UP_DIR"

          # Verify source exists
          if [ ! -d "out" ]; then
            echo "‚ùå ERROR: out/ directory not found!"
            ls -la
            exit 1
          fi

          # Check if frontend already copied (skip if already present)
          if [ -f "$UP_DIR/index.html" ]; then
            echo "‚úÖ Frontend already present in bundle, skipping copy"
          else
            echo "‚ö†Ô∏è Frontend missing from bundle, copying manually..."
            # Create _up_ if it doesn't exist
            mkdir -p "$UP_DIR"
            # Copy all frontend assets
            cp -r out/* "$UP_DIR/"
            echo "‚úÖ Frontend copied successfully"
          fi

          # Final verification
          ls -la "$UP_DIR" | head -10

      - name: Verify frontend in app bundle
        run: |
          APP_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${{ env.APP_NAME }}.app"
          echo "=== Checking frontend assets in bundle ==="

          echo ""
          echo "=== _up_ directory contents ==="
          ls -la "$APP_PATH/Contents/Resources/_up_/" || echo "‚ùå _up_ directory not found!"

          echo ""
          echo "=== Check for index.html in bundle ==="
          if [ -f "$APP_PATH/Contents/Resources/_up_/index.html" ]; then
            echo "‚úÖ index.html found in bundle ($(wc -c < "$APP_PATH/Contents/Resources/_up_/index.html") bytes)"
          else
            echo "‚ùå ERROR: index.html NOT in bundle!"
            echo ""
            echo "Searching for index.html anywhere in bundle..."
            find "$APP_PATH" -name "index.html" 2>/dev/null || echo "Not found anywhere"
            echo ""
            echo "Full _up_ structure:"
            find "$APP_PATH/Contents/Resources/_up_" -type f 2>/dev/null | head -50 || echo "No files found"
            exit 1
          fi

          echo ""
          echo "=== Check for _next/ in bundle ==="
          if [ -d "$APP_PATH/Contents/Resources/_up_/_next" ]; then
            echo "‚úÖ _next/ directory found in bundle"
            find "$APP_PATH/Contents/Resources/_up_/_next" -type f | wc -l | xargs echo "   Files in _next/:"
          else
            echo "‚ùå ERROR: _next/ directory NOT in bundle!"
            exit 1
          fi

      - name: Verify build and patch Info.plist
        run: |
          APP_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${{ env.APP_NAME }}.app"
          echo "‚úÖ App: $APP_PATH"
          du -sh "$APP_PATH"
          lipo -info "$APP_PATH/Contents/MacOS/hablara"

          # Set CFBundleDisplayName for accented display name in Finder/Dock
          plutil -replace CFBundleDisplayName -string "Hablar√°" "$APP_PATH/Contents/Info.plist"
          echo "‚úÖ CFBundleDisplayName set to 'Hablar√°'"

          # Set CFBundleVersion to match --bundle-version in altool upload
          plutil -replace CFBundleVersion -string "${{ github.run_number }}" "$APP_PATH/Contents/Info.plist"
          echo "‚úÖ CFBundleVersion set to '${{ github.run_number }}'"

      # ========================================
      # 6. Sign App Bundle
      # ========================================
      - name: Sign app bundle
        run: |
          APP_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${{ env.APP_NAME }}.app"
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          CERT="${{ steps.certs.outputs.distribution_cert }}"
          ENTITLEMENTS="src-tauri/entitlements.plist"

          # Embed provisioning profile
          cp $RUNNER_TEMP/embedded.provisionprofile "$APP_PATH/Contents/embedded.provisionprofile"

          # Sign whisper binaries with CHILD entitlements (inherit sandbox, no provisioning profile needed)
          # Using child-entitlements.plist instead of main entitlements to avoid ITMS-90885
          CHILD_ENTITLEMENTS="src-tauri/child-entitlements.plist"
          echo "Signing whisper binaries with child entitlements..."
          for binary in "$APP_PATH/Contents/Resources/binaries/whisper-"*; do
            if [ -f "$binary" ]; then
              echo "Signing: $binary"
              codesign --force --options runtime \
                --sign "$CERT" \
                --keychain $KEYCHAIN_PATH \
                --entitlements "$CHILD_ENTITLEMENTS" \
                "$binary"
            fi
          done

          # Sign all nested binaries in MacOS (deep signing)
          find "$APP_PATH/Contents/MacOS" -type f -perm +111 | while read binary; do
            echo "Signing binary: $binary"
            codesign --force --options runtime \
              --sign "$CERT" \
              --keychain $KEYCHAIN_PATH \
              --entitlements "$ENTITLEMENTS" \
              "$binary"
          done

          # Sign frameworks if any
          if [ -d "$APP_PATH/Contents/Frameworks" ]; then
            find "$APP_PATH/Contents/Frameworks" -name "*.dylib" -o -name "*.framework" | while read item; do
              echo "Signing framework: $item"
              codesign --force --options runtime \
                --sign "$CERT" \
                --keychain $KEYCHAIN_PATH \
                "$item" 2>/dev/null || true
            done
          fi

          # Sign the entire bundle
          codesign --force --options runtime \
            --sign "$CERT" \
            --keychain $KEYCHAIN_PATH \
            --entitlements "$ENTITLEMENTS" \
            "$APP_PATH"

          # Verify
          codesign --verify --deep --strict "$APP_PATH"
          echo "‚úÖ App signed and verified"

      # ========================================
      # 7. Create & Sign PKG
      # ========================================
      - name: Create signed PKG
        run: |
          set -e
          APP_PATH="src-tauri/target/universal-apple-darwin/release/bundle/macos/${{ env.APP_NAME }}.app"
          PKG_PATH="${{ runner.temp }}/${{ env.APP_NAME }}-${{ inputs.version }}.pkg"
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          INST_CERT="${{ steps.certs.outputs.installer_cert }}"

          # Verify app exists and has content
          echo "üìã Verifying app bundle..."
          ls -la "$APP_PATH/"
          ls -la "$APP_PATH/Contents/"
          ls -la "$APP_PATH/Contents/MacOS/"
          file "$APP_PATH/Contents/MacOS/hablara"

          # Verify code signature before PKG creation
          echo "üîè Verifying app signature..."
          codesign -dvvv "$APP_PATH"

          # Copy app to temp location using ditto (preserves Extended Attributes + symlinks)
          TEMP_APP="${{ runner.temp }}/${{ env.APP_NAME }}.app"
          echo "üì¶ Copying app with ditto (preserves xattrs)..."
          ditto "$APP_PATH" "$TEMP_APP"

          # Verify ditto copy
          echo "üìã Verifying ditto copy..."
          codesign -dvvv "$TEMP_APP"

          # Create signed PKG with productbuild --component (App Store required method)
          # Reference: https://v2.tauri.app/distribute/app-store/
          echo "üì¶ Creating PKG with productbuild --component..."
          xcrun productbuild \
            --sign "$INST_CERT" \
            --keychain "$KEYCHAIN_PATH" \
            --component "$TEMP_APP" /Applications \
            "$PKG_PATH"

          echo "‚úÖ PKG created"
          ls -lh "$PKG_PATH"

          # Verify signature
          echo "üîè Verifying PKG signature..."
          pkgutil --check-signature "$PKG_PATH"

          # Verify PKG contents
          echo "üìã PKG payload files (first 30):"
          pkgutil --payload-files "$PKG_PATH" | head -30 || echo "Warning: Could not list payload files"

          # Expand and verify PKG structure
          echo "üìã Expanding PKG to verify structure..."
          EXPAND_DIR="${{ runner.temp }}/pkg-expanded"
          pkgutil --expand "$PKG_PATH" "$EXPAND_DIR" || echo "Warning: Could not expand PKG"
          ls -la "$EXPAND_DIR/" || true
          ls -la "$EXPAND_DIR/"*.pkg/ 2>/dev/null || true

      - name: Upload PKG artifact
        uses: actions/upload-artifact@v4
        with:
          name: hablara-${{ inputs.version }}-macos-universal.pkg
          path: ${{ runner.temp }}/${{ env.APP_NAME }}-${{ inputs.version }}.pkg
          retention-days: 30

      # ========================================
      # 8. Upload to App Store Connect
      # ========================================
      - name: Setup API Key
        env:
          ASC_API_PRIVATE_KEY_BASE64: ${{ secrets.ASC_API_PRIVATE_KEY_BASE64 }}
          ASC_API_KEY_ID: ${{ secrets.ASC_API_KEY_ID }}
        run: |
          mkdir -p ~/.private_keys
          echo "$ASC_API_PRIVATE_KEY_BASE64" | base64 -d > ~/.private_keys/AuthKey_${ASC_API_KEY_ID}.p8
          chmod 600 ~/.private_keys/AuthKey_${ASC_API_KEY_ID}.p8

      - name: Upload to App Store Connect
        timeout-minutes: 30
        env:
          ASC_API_KEY_ID: ${{ secrets.ASC_API_KEY_ID }}
          ASC_API_ISSUER_ID: ${{ secrets.ASC_API_ISSUER_ID }}
        run: |
          PKG_PATH="${{ runner.temp }}/${{ env.APP_NAME }}-${{ inputs.version }}.pkg"

          xcrun altool --upload-package "$PKG_PATH" \
            --type macos \
            --apple-id "${{ env.APPLE_ID }}" \
            --apiKey "$ASC_API_KEY_ID" \
            --apiIssuer "$ASC_API_ISSUER_ID" \
            --bundle-id "${{ env.APP_IDENTIFIER }}" \
            --bundle-short-version-string "${{ inputs.version }}" \
            --bundle-version "${{ github.run_number }}"

          echo "‚úÖ Uploaded to App Store Connect"

      # ========================================
      # 9. Cleanup
      # ========================================
      - name: Cleanup
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db 2>/dev/null || true
          rm -f $RUNNER_TEMP/certificates.p12 $RUNNER_TEMP/embedded.provisionprofile
          rm -rf ~/.private_keys

      - name: Summary
        run: |
          echo "## ‚úÖ App Store Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Architecture:** Universal (arm64 + x86_64)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Build uploaded to App Store Connect. Check TestFlight in 5-15 minutes." >> $GITHUB_STEP_SUMMARY
