"use client";

/**
 * useRecordings - Persistent Storage Management
 *
 * Verwaltet gespeicherte Aufnahmen: Liste/Speichern/Löschen, Storage Stats,
 * Config Updates, Baseline Emotion Calculation, Audio Download. Nutzt Tauri
 * Commands für Filesystem-Access. Auto-Refresh bei Änderungen.
 */

import { useState, useCallback, useEffect } from "react";
import { useTauri } from "./useTauri";
import { logger } from "@/lib/logger";
import type {
  RecordingMetadata,
  StorageConfig,
  StorageStats,
  AudioValidationMeta,
  BaselineResult,
} from "@/lib/types";

/** Result of a recording download operation */
export interface DownloadResult {
  /** Whether the download completed successfully */
  success: boolean;
  /** The file path where the recording was saved (Tauri only) */
  filePath?: string;
  /** Whether the user cancelled the save dialog */
  cancelled?: boolean;
  /** Error message if download failed */
  error?: string;
}

export interface UseRecordingsReturn {
  recordings: RecordingMetadata[];
  isLoading: boolean;
  error: string | null;
  stats: StorageStats | null;
  config: StorageConfig | null;
  refresh: () => Promise<void>;
  saveRecording: (
    audioData: string,
    metadata: Omit<RecordingMetadata, "id" | "createdAt" | "appVersion">
  ) => Promise<string | null>;
  getRecordingAudio: (id: string) => Promise<string | null>;
  downloadRecording: (id: string, createdAt: string) => Promise<DownloadResult>;
  deleteRecording: (id: string) => Promise<boolean>;
  clearAllRecordings: () => Promise<number>;
  updateConfig: (config: StorageConfig) => Promise<boolean>;
  getBaselineEmotion: () => Promise<BaselineResult | null>;
}

/**
 * Hook for managing persistent audio recordings
 */
export function useRecordings(): UseRecordingsReturn {
  const { isTauri, isReady, invoke } = useTauri();

  const [recordings, setRecordings] = useState<RecordingMetadata[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [stats, setStats] = useState<StorageStats | null>(null);
  const [config, setConfig] = useState<StorageConfig | null>(null);

  /**
   * Fetch recordings and stats from backend
   */
  const refresh = useCallback(async () => {
    if (!isTauri) return;

    setIsLoading(true);
    setError(null);

    try {
      const [recordingsList, storageStats, storageConfig] = await Promise.all([
        invoke<RecordingMetadata[]>("list_recordings"),
        invoke<StorageStats>("get_storage_stats"),
        invoke<StorageConfig>("get_storage_config"),
      ]);

      setRecordings(recordingsList || []);
      setStats(storageStats);
      setConfig(storageConfig);
    } catch (err) {
      const message = err instanceof Error ? err.message : "Failed to load recordings";
      setError(message);
    } finally {
      setIsLoading(false);
    }
  }, [isTauri, invoke]);

  /**
   * Save a recording
   */
  const saveRecording = useCallback(
    async (
      audioData: string,
      metadata: Omit<RecordingMetadata, "id" | "createdAt" | "appVersion">
    ): Promise<string | null> => {
      if (!isTauri) return null;

      try {
        // The backend will fill in id, createdAt, and appVersion
        const fullMetadata: RecordingMetadata = {
          ...metadata,
          id: "", // Will be generated by backend
          createdAt: "", // Will be set by backend
          appVersion: "", // Will be set by backend
        };

        const id = await invoke<string>("save_recording", {
          audioData,
          metadata: fullMetadata,
        });

        // Refresh list after save
        await refresh();

        return id;
      } catch (err) {
        const message = err instanceof Error ? err.message : "Failed to save recording";
        logger.error('useRecordings', 'Save recording failed', err);
        setError(message);
        return null;
      }
    },
    [isTauri, invoke, refresh]
  );

  /**
   * Get recording audio by ID (returns Base64 encoded WAV)
   */
  const getRecordingAudio = useCallback(
    async (id: string): Promise<string | null> => {
      if (!isTauri) return null;

      try {
        return await invoke<string>("get_recording_audio", { id });
      } catch (err) {
        const message = err instanceof Error ? err.message : "Failed to get recording audio";
        logger.error('useRecordings', 'Failed to get recording audio', err);
        setError(message);
        return null;
      }
    },
    [isTauri, invoke]
  );

  /**
   * Download recording as WAV file
   */
  const downloadRecording = useCallback(
    async (id: string, createdAt: string): Promise<DownloadResult> => {
      // 1. Audio-Daten abrufen
      const audioData = await getRecordingAudio(id);
      if (!audioData) {
        return { success: false, error: "Audio nicht gefunden" };
      }

      // 2. Dateiname aus Timestamp generieren
      let date = new Date(createdAt);
      if (isNaN(date.getTime())) {
        logger.warn('useRecordings', 'Invalid createdAt timestamp, using current time', { createdAt });
        date = new Date();
      }
      const dateStr = date.toISOString().slice(0, 10);
      const timeStr = date.toTimeString().slice(0, 8).replace(/:/g, "-");
      const defaultFileName = `Hablara_${dateStr}_${timeStr}.wav`;

      // 3. Base64 → Uint8Array (Pattern aus AudioPlayer.tsx)
      let bytes: Uint8Array;
      try {
        const binaryString = atob(audioData);
        bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
      } catch (error) {
        logger.error('useRecordings', 'Invalid Base64 audio data', error);
        return { success: false, error: "Audio-Daten ungültig" };
      }

      // 4. Platform-spezifisches Speichern
      if (isTauri) {
        try {
          const { save } = await import("@tauri-apps/plugin-dialog");
          const { writeFile } = await import("@tauri-apps/plugin-fs");

          const filePath = await save({
            defaultPath: defaultFileName,
            filters: [{ name: "Audio", extensions: ["wav"] }],
          });

          if (!filePath) {
            return { success: false, cancelled: true };
          }

          await writeFile(filePath, bytes);
          logger.info('useRecordings', 'Recording downloaded', { id, filePath });
          return { success: true, filePath };
        } catch (err) {
          const message = err instanceof Error ? err.message : "Download fehlgeschlagen";
          logger.error('useRecordings', 'Download failed', err);
          return { success: false, error: message };
        }
      } else {
        // Browser-Fallback (Development)
        try {
          // Create proper ArrayBuffer for Blob
          const blob = new Blob([new Uint8Array(bytes)], { type: "audio/wav" });
          const url = URL.createObjectURL(blob);
          const anchor = document.createElement("a");
          anchor.href = url;
          anchor.download = defaultFileName;
          document.body.appendChild(anchor);
          anchor.click();
          document.body.removeChild(anchor);
          URL.revokeObjectURL(url);
          return { success: true };
        } catch (err) {
          const message = err instanceof Error ? err.message : "Download fehlgeschlagen";
          logger.error('useRecordings', 'Browser download failed', err);
          return { success: false, error: message };
        }
      }
    },
    [isTauri, getRecordingAudio]
  );

  /**
   * Delete a recording by ID
   */
  const deleteRecording = useCallback(
    async (id: string): Promise<boolean> => {
      if (!isTauri) {
        logger.warn('useRecordings', 'Not in Tauri environment, skipping delete');
        return false;
      }

      try {
        await invoke<void>("delete_recording", { id });
        await refresh();
        return true;
      } catch (err) {
        const message = err instanceof Error ? err.message : "Failed to delete recording";
        logger.error('useRecordings', 'Delete failed', err);
        setError(message);
        return false;
      }
    },
    [isTauri, invoke, refresh]
  );

  /**
   * Clear all recordings
   */
  const clearAllRecordings = useCallback(async (): Promise<number> => {
    if (!isTauri) {
      logger.warn('useRecordings', 'Not in Tauri environment, skipping clear all');
      return 0;
    }

    try {
      const count = await invoke<number>("clear_all_recordings");
      await refresh();
      return count || 0;
    } catch (err) {
      const message = err instanceof Error ? err.message : "Failed to clear recordings";
      logger.error('useRecordings', 'Clear all failed', err);
      setError(message);
      return 0;
    }
  }, [isTauri, invoke, refresh]);

  /**
   * Update storage configuration
   */
  const updateConfig = useCallback(
    async (newConfig: StorageConfig): Promise<boolean> => {
      if (!isTauri) return false;

      try {
        await invoke<void>("update_storage_config", { config: newConfig });
        setConfig(newConfig);
        return true;
      } catch (err) {
        const message = err instanceof Error ? err.message : "Failed to update config";
        setError(message);
        return false;
      }
    },
    [isTauri, invoke]
  );

  /**
   * Get baseline emotion from all recordings
   */
  const getBaselineEmotion = useCallback(async (): Promise<BaselineResult | null> => {
    if (!isTauri) return null;

    try {
      return await invoke<BaselineResult | null>("calculate_baseline_emotion");
    } catch (err) {
      const message = err instanceof Error ? err.message : "Failed to get baseline emotion";
      logger.error('useRecordings', 'Failed to get baseline emotion', err);
      setError(message);
      return null;
    }
  }, [isTauri, invoke]);

  // Initial load
  useEffect(() => {
    if (isReady && isTauri) {
      refresh();
    }
  }, [isReady, isTauri, refresh]);

  return {
    recordings,
    isLoading,
    error,
    stats,
    config,
    refresh,
    saveRecording,
    getRecordingAudio,
    downloadRecording,
    deleteRecording,
    clearAllRecordings,
    updateConfig,
    getBaselineEmotion,
  };
}

/**
 * Helper to create AudioValidationMeta from recording data
 */
export function createAudioValidationMeta(
  rmsEnergy: number,
  durationMs: number,
  sampleCount: number,
  passed: boolean
): AudioValidationMeta {
  return {
    rmsEnergy,
    durationMs,
    sampleCount,
    passed,
  };
}

/**
 * Format duration in ms to human readable string
 */
export function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;

  if (minutes > 0) {
    return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
  }
  return `${seconds}s`;
}

/**
 * Format file size to human readable string
 */
export function formatFileSize(bytes: number): string {
  if (bytes < 1024) {
    return `${bytes} B`;
  }
  if (bytes < 1024 * 1024) {
    return `${(bytes / 1024).toFixed(1)} KB`;
  }
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

/**
 * Format date to local string
 */
export function formatDate(isoString: string): string {
  const date = new Date(isoString);
  return date.toLocaleString("de-DE", {
    day: "2-digit",
    month: "2-digit",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
}
